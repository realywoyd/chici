<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥ 2089 - Telegram Mini App</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0d0d1a;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #loading-screen {
            background: #0d0d1a;
            text-align: center;
        }
        #loading-screen h1 {
            font-size: 24px;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffcc;
            animation: flicker 1.5s infinite alternate;
        }
        #loading-screen p {
            font-size: 14px;
            text-shadow: 0 0 5px #00ffcc;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        #character-screen {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
            padding: 20px;
            border-radius: 5px;
        }
        #game-screen {
            width: 100%;
            height: 100%;
        }
        #game-ui {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 200px;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border: 1px solid #ff00ff;
            font-size: 12px;
            box-shadow: 0 0 10px #ff00ff;
        }
        .neon-text {
            text-shadow: 0 0 5px #00ffcc, 0 0 10px #ff00ff;
        }
        button {
            background: #ff00ff;
            color: #00ffcc;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
            font-size: 10px;
            text-shadow: 0 0 5px #00ffcc;
            transition: all 0.3s;
        }
        button:hover {
            background: #00ffcc;
            color: #ff00ff;
        }
        #output {
            height: 60px;
            overflow-y: auto;
            border: 1px dashed #00ffcc;
            padding: 5px;
        }
        .notification {
            padding: 3px;
            margin: 2px 0;
            transition: opacity 0.5s ease-out;
            text-shadow: 0 0 5px #00ffcc;
        }
        .notification.fade-out {
            opacity: 0;
        }
        #joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 255, 0.2);
            border-radius: 50%;
            touch-action: none;
            border: 1px solid #ff00ff;
        }
        #joystick-knob {
            width: 40px;
            height: 40px;
            background: #00ffcc;
            border-radius: 50%;
            position: absolute;
            top: 20px;
            left: 20px;
            box-shadow: 0 0 10px #00ffcc;
        }
        #action-buttons-mobile {
            position: absolute;
            bottom: 20px;
            right: 20px;
        }
        #upgrade-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffcc;
            display: none;
            border-radius: 5px;
            text-align: center;
        }
        #upgrade-menu h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #00ffcc;
        }
        #upgrade-menu p {
            margin: 5px 0;
            font-size: 12px;
        }
        #upgrade-menu button {
            width: 100%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- –≠–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏ -->
    <div id="loading-screen" class="screen">
        <h1 class="neon-text">–ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥ 2089</h1>
        <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∏—Å—Ç–µ–º—ã...</p>
    </div>

    <!-- –≠–∫—Ä–∞–Ω —Å–æ–∑–¥–∞–Ω–∏—è/–≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ -->
    <div id="character-screen" class="screen">
        <h1 class="neon-text">üåÉ –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥</h1>
        <div id="create-character">
            <input id="char-name" type="text" placeholder="–ò–º—è" style="width: 80px; background: #1a1a33; color: #00ffcc; border: 1px solid #ff00ff; padding: 2px;">
            <button onclick="createCharacter('–•–∞–∫–µ—Ä')">–•–∞–∫–µ—Ä</button>
            <button onclick="createCharacter('–ù–∞–µ–º–Ω–∏–∫')">–ù–∞–µ–º–Ω–∏–∫</button>
            <button onclick="createCharacter('–¢–µ—Ö–Ω–∏–∫')">–¢–µ—Ö–Ω–∏–∫</button>
        </div>
        <div id="character-list"></div>
    </div>

    <!-- –≠–∫—Ä–∞–Ω –∏–≥—Ä—ã -->
    <div id="game-screen" class="screen">
        <div id="game-ui">
            <h1 class="neon-text">üåÉ –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥</h1>
            <div id="output">
                –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥!<br>
            </div>
            <div id="action-buttons">
                <button onclick="startMission()">–ú–∏—Å—Å–∏—è</button>
                <button onclick="completeMission()">–í—ã–ø–æ–ª–Ω–∏—Ç—å</button>
                <button onclick="showUpgradeMenu()">–ü—Ä–æ–∫–∞—á–∫–∞</button>
            </div>
        </div>
        <div id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div id="action-buttons-mobile">
            <button onclick="startMission()" style="width: 80px;">–ú–∏—Å—Å–∏—è</button><br>
            <button onclick="completeMission()" style="width: 80px;">–í—ã–ø–æ–ª–Ω–∏—Ç—å</button><br>
            <button onclick="showUpgradeMenu()" style="width: 80px;">–ü—Ä–æ–∫–∞—á–∫–∞</button>
        </div>
        <div id="upgrade-menu">
            <h3 class="neon-text">–ü—Ä–æ–∫–∞—á–∫–∞</h3>
            <p id="upgrade-stats"></p>
            <button onclick="upgradeStat('strength')">–°–∏–ª–∞ +1 (100 –∫—Ä.)</button>
            <button onclick="upgradeStat('intelligence')">–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç +1 (100 –∫—Ä.)</button>
            <button onclick="upgradeStat('agility')">–õ–æ–≤–∫–æ—Å—Ç—å +1 (100 –∫—Ä.)</button>
            <button onclick="hideUpgradeMenu()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // Telegram Web Apps
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();

        // –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        const loadingScreen = document.getElementById("loading-screen");
        const characterScreen = document.getElementById("character-screen");
        const gameScreen = document.getElementById("game-screen");
        const output = document.getElementById("output");
        const createCharacterDiv = document.getElementById("create-character");

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let currentCharacter = null;
        let characters = [];
        let selectedCharacter = null;
        let currentMission = null;

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ü–µ–Ω—ã Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "low-power" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById("game-screen").appendChild(renderer.domElement);

        // –¢–µ–∫—Å—Ç—É—Ä—ã
        const textureLoader = new THREE.TextureLoader();
        const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(5, 5);
        const buildingTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const neonLight = new THREE.PointLight(0xff00ff, 1, 30);
        neonLight.position.set(0, 10, 0);
        scene.add(neonLight);

        // –ó–µ–º–ª—è
        const groundGeometry = new THREE.PlaneGeometry(50, 50);
        const groundMaterial = new THREE.MeshBasicMaterial({ map: groundTexture });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // –ó–¥–∞–Ω–∏—è
        const buildingMaterial = new THREE.MeshBasicMaterial({ map: buildingTexture });
        for (let i = 0; i < 10; i++) {
            const height = Math.random() * 10 + 5;
            const building = new THREE.Mesh(new THREE.BoxGeometry(3, height, 3), buildingMaterial);
            building.position.set(Math.random() * 40 - 20, height / 2, Math.random() * 40 - 20);
            scene.add(building);
        }

        // –ù–µ–æ–Ω–æ–≤—ã–π –¥–æ–∂–¥—å
        const particleCount = 200;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = Math.random() * 50 - 25;
            positions[i * 3 + 1] = Math.random() * 20 + 5;
            positions[i * 3 + 2] = Math.random() * 50 - 25;
            colors[i * 3] = Math.random() > 0.5 ? 1 : 0;
            colors[i * 3 + 1] = 0;
            colors[i * 3 + 2] = Math.random() > 0.5 ? 1 : 0;
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true });
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã
        const missionObjects = [];
        function createMissionObjects() {
            missionObjects.forEach(obj => scene.remove(obj));
            missionObjects.length = 0;

            const terminal = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
            terminal.position.set(-5, 1, -5);
            terminal.userData = { type: "hack" };
            scene.add(terminal);
            missionObjects.push(terminal);

            const drone = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff00ff }));
            drone.position.set(5, 1, 5);
            drone.userData = { type: "fight" };
            scene.add(drone);
            missionObjects.push(drone);

            const energyBlock = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            energyBlock.position.set(0, 0.75, 5);
            energyBlock.userData = { type: "repair" };
            scene.add(energyBlock);
            missionObjects.push(energyBlock);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        function createCharacterModel(role) {
            if (currentCharacter) scene.remove(currentCharacter);
            const group = new THREE.Group();
            let color = role === "–•–∞–∫–µ—Ä" ? 0x00ffcc : role === "–ù–∞–µ–º–Ω–∏–∫" ? 0xff00ff : 0xffff00;
            const material = new THREE.MeshBasicMaterial({ color });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8), material);
            body.position.y = 0.6;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), material);
            head.position.y = 1.3;
            group.add(head);

            currentCharacter = group;
            currentCharacter.position.set(0, 0, 0);
            scene.add(currentCharacter);
        }

        // –î–∂–æ–π—Å—Ç–∏–∫
        const joystick = document.getElementById("joystick");
        const knob = document.getElementById("joystick-knob");
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let direction = { x: 0, y: 0 };

        joystick.addEventListener("touchstart", (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            joystickOrigin = { x: touch.clientX, y: touch.clientY };
        });

        joystick.addEventListener("touchmove", (e) => {
            e.preventDefault();
            if (!joystickActive || !currentCharacter) return;
            const touch = e.touches[0];
            const dx = touch.clientX - joystickOrigin.x;
            const dy = touch.clientY - joystickOrigin.y;
            const distance = Math.min(40, Math.sqrt(dx * dx + dy * dy));
            const angle = Math.atan2(dy, dx);
            direction.x = Math.cos(angle) * (distance / 40);
            direction.y = Math.sin(angle) * (distance / 40);
            knob.style.left = `${20 + Math.cos(angle) * distance}px`;
            knob.style.top = `${20 + Math.sin(angle) * distance}px`;
        });

        joystick.addEventListener("touchend", () => {
            joystickActive = false;
            direction = { x: 0, y: 0 };
            knob.style.left = "20px";
            knob.style.top = "20px";
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è
        function animate() {
            requestAnimationFrame(animate);

            if (currentCharacter) {
                const speed = 0.05;
                currentCharacter.position.x += direction.x * speed;
                currentCharacter.position.z += direction.y * speed;

                if (direction.x !== 0 || direction.y !== 0) {
                    currentCharacter.rotation.y = Math.atan2(direction.x, direction.y);
                    currentCharacter.children[0].rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                }

                camera.position.set(
                    currentCharacter.position.x,
                    currentCharacter.position.y + 8,
                    currentCharacter.position.z + 10
                );
                camera.lookAt(currentCharacter.position);
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] -= 0.05;
                if (positions[i * 3 + 1] < 0) {
                    positions[i * 3 + 1] = Math.random() * 20 + 5;
                    positions[i * 3] = Math.random() * 50 - 25;
                    positions[i * 3 + 2] = Math.random() * 50 - 25;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞–º–∏
        function showScreen(screenId) {
            loadingScreen.style.display = "none";
            characterScreen.style.display = "none";
            gameScreen.style.display = "none";
            document.getElementById(screenId).style.display = "flex";
        }

        // –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
        function appendMessage(text) {
            const message = document.createElement("div");
            message.className = "notification";
            message.innerHTML = text;
            output.appendChild(message);
            output.scrollTop = output.scrollHeight;
            setTimeout(() => {
                message.classList.add("fade-out");
                setTimeout(() => message.remove(), 500);
            }, 2000);
        }

        function createCharacter(role) {
            if (characters.length >= 3) {
                window.Telegram.WebApp.showAlert("–ú–∞–∫—Å–∏–º—É–º 3 –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!");
                return;
            }
            const name = document.getElementById("char-name").value.trim();
            if (!name) {
                window.Telegram.WebApp.showAlert("–í–≤–µ–¥–∏ –∏–º—è!");
                return;
            }
            const character = {
                name,
                role,
                creds: 0,
                stats: {
                    strength: role === "–ù–∞–µ–º–Ω–∏–∫" ? 10 : 5,
                    intelligence: role === "–•–∞–∫–µ—Ä" ? 10 : 5,
                    agility: role === "–¢–µ—Ö–Ω–∏–∫" ? 10 : 5
                }
            };
            characters.push(character);
            document.getElementById("char-name").value = "";
            updateCharacterList();
            saveProgress();
            window.Telegram.WebApp.showAlert(`–ü–µ—Ä—Å–æ–Ω–∞–∂ ${name} —Å–æ–∑–¥–∞–Ω!`);
        }

        function updateCharacterList() {
            const charList = document.getElementById("character-list");
            charList.innerHTML = "<h3>–ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</h3>";
            characters.forEach((char, index) => {
                charList.innerHTML += `
                    <button onclick="selectCharacter(${index})">
                        ${char.name} (${char.role}) - ${char.creds} –∫—Ä.
                        [–°:${char.stats.strength} –ò:${char.stats.intelligence} –õ:${char.stats.agility}]
                    </button><br>`;
            });
            if (characters.length >= 3) createCharacterDiv.style.display = "none";
            else createCharacterDiv.style.display = "block";
        }

        function selectCharacter(index) {
            selectedCharacter = characters[index];
            createCharacterModel(selectedCharacter.role);
            createMissionObjects();
            showScreen("game-screen");
            appendMessage(`–í—ã–±—Ä–∞–Ω: ${selectedCharacter.name}.`);
        }

        function startMission() {
            if (!selectedCharacter) return;
            const missions = {
                "–•–∞–∫–µ—Ä": [
                    { target: [-5, -5], reward: 30 + selectedCharacter.stats.intelligence * 5, desc: "–í–∑–ª–æ–º–∞—Ç—å —Ç–µ—Ä–º–∏–Ω–∞–ª", type: "hack" },
                    { target: [7, -7], reward: 50 + selectedCharacter.stats.intelligence * 5, desc: "–í–∑–ª–æ–º–∞—Ç—å —Å–µ—Ä–≤–µ—Ä", type: "hack" }
                ],
                "–ù–∞–µ–º–Ω–∏–∫": [
                    { target: [5, 5], reward: 40 + selectedCharacter.stats.strength * 5, desc: "–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å –¥—Ä–æ–Ω–∞", type: "fight" },
                    { target: [-7, 7], reward: 60 + selectedCharacter.stats.strength * 5, desc: "–õ–∏–∫–≤–∏–¥–∏—Ä–æ–≤–∞—Ç—å —Ü–µ–ª—å", type: "fight" }
                ],
                "–¢–µ—Ö–Ω–∏–∫": [
                    { target: [0, 5], reward: 35 + selectedCharacter.stats.agility * 5, desc: "–ü–æ—á–∏–Ω–∏—Ç—å –¥—Ä–æ–Ω", type: "repair" },
                    { target: [5, -5], reward: 55 + selectedCharacter.stats.agility * 5, desc: "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫", type: "repair" }
                ]
            };
            const missionList = missions[selectedCharacter.role];
            currentMission = missionList[Math.floor(Math.random() * missionList.length)];
            appendMessage(`–¶–µ–ª—å: ${currentMission.desc}. –ò–¥–∏ –∫ (${currentMission.target[0]}, ${currentMission.target[1]}). –ù–∞–≥—Ä–∞–¥–∞: ${currentMission.reward} –∫—Ä.`);
        }

        function completeMission() {
            if (!selectedCharacter || !currentMission) return;
            const pos = currentCharacter.position;
            const [targetX, targetZ] = currentMission.target;
            if (Math.abs(pos.x - targetX) < 1 && Math.abs(pos.z - targetZ) < 1) {
                selectedCharacter.creds += currentMission.reward;
                appendMessage(`‚ö°Ô∏è ${currentMission.desc}: +${currentMission.reward} –∫—Ä.`);
                window.Telegram.WebApp.showAlert(`–ú–∏—Å—Å–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞! +${currentMission.reward} –∫—Ä–µ–¥–∏—Ç–æ–≤`);
                missionObjects.find(obj => obj.userData.type === currentMission.type && 
                    Math.abs(obj.position.x - targetX) < 1 && Math.abs(obj.position.z - targetZ) < 1).visible = false;
                setTimeout(() => createMissionObjects(), 5000);
                currentMission = null;
                updateCharacterList();
                saveProgress();
            } else {
                appendMessage("üí• –ù–µ –≤ —Ç–æ—á–∫–µ!");
            }
        }

        // –ü—Ä–æ–∫–∞—á–∫–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
        const upgradeMenu = document.getElementById("upgrade-menu");
        const upgradeStats = document.getElementById("upgrade-stats");

        function showUpgradeMenu() {
            if (!selectedCharacter) return;
            upgradeStats.innerHTML = `${selectedCharacter.name}: ${selectedCharacter.creds} –∫—Ä.<br>
                –°–∏–ª–∞: ${selectedCharacter.stats.strength}<br>
                –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç: ${selectedCharacter.stats.intelligence}<br>
                –õ–æ–≤–∫–æ—Å—Ç—å: ${selectedCharacter.stats.agility}`;
            upgradeMenu.style.display = "block";
        }

        function hideUpgradeMenu() {
            upgradeMenu.style.display = "none";
        }

        function upgradeStat(stat) {
            if (!selectedCharacter || selectedCharacter.creds < 100) {
                appendMessage("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!");
                window.Telegram.WebApp.showAlert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!");
                return;
            }
            selectedCharacter.creds -= 100;
            selectedCharacter.stats[stat] += 1;
            appendMessage(`–£–ª—É—á—à–µ–Ω–æ: ${stat === "strength" ? "–°–∏–ª–∞" : stat === "intelligence" ? "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç" : "–õ–æ–≤–∫–æ—Å—Ç—å"} +1!`);
            window.Telegram.WebApp.showAlert(`–£–ª—É—á—à–µ–Ω–æ: ${stat === "strength" ? "–°–∏–ª–∞" : stat === "intelligence" ? "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç" : "–õ–æ–≤–∫–æ—Å—Ç—å"} +1`);
            updateCharacterList();
            saveProgress();
            showUpgradeMenu();
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function saveProgress() {
            try {
                window.Telegram.WebApp.CloudStorage.setItem("characters", JSON.stringify(characters), () => {
                    console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω");
                });
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:", e);
            }
        }

        function loadProgress(callback) {
            try {
                window.Telegram.WebApp.CloudStorage.getItem("characters", (error, result) => {
                    if (!error && result) {
                        characters = JSON.parse(result);
                        console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∂–µ–Ω:", characters);
                    } else {
                        console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–æ–≤—ã–π —Å—Ç–∞—Ä—Ç");
                    }
                    callback();
                });
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:", e);
                callback();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        function initializeGame() {
            showScreen("loading-screen");
            loadProgress(() => {
                setTimeout(() => {
                    updateCharacterList();
                    showScreen("character-screen");
                }, 2000); // –≠–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è 2 —Å–µ–∫—É–Ω–¥—ã
            });
        }

        initializeGame();

        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
