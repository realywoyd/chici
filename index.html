<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>–ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥ 2089 - Telegram Mini App</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0d0d1a;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #loading-screen {
            background: #0d0d1a;
            text-align: center;
        }
        #loading-screen h1 {
            font-size: 24px;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffcc;
            animation: flicker 1.5s infinite alternate;
        }
        #loading-screen p {
            font-size: 14px;
            text-shadow: 0 0 5px #00ffcc;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        #character-screen {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
            padding: 20px;
            border-radius: 5px;
        }
        #game-screen {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }
        .neon-text {
            text-shadow: 0 0 5px #00ffcc, 0 0 10px #ff00ff;
        }
        button {
            background: #ff00ff;
            color: #00ffcc;
            border: none;
            padding: 10px 15px; /* –£–≤–µ–ª–∏—á–∏–ª –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –Ω–∞–∂–∞—Ç–∏—è */
            margin: 5px;
            cursor: pointer;
            font-size: 12px;
            text-shadow: 0 0 5px #00ffcc;
            transition: all 0.3s;
            border-radius: 5px;
        }
        button:hover, button:active {
            background: #00ffcc;
            color: #ff00ff;
        }
        #welcome-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #00ffcc;
            opacity: 0;
            transition: opacity 1s ease-out;
        }
        #joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 255, 0.2);
            border-radius: 50%;
            touch-action: none;
            border: 1px solid #ff00ff;
        }
        #joystick-knob {
            width: 40px;
            height: 40px;
            background: #00ffcc;
            border-radius: 50%;
            position: absolute;
            top: 20px;
            left: 20px;
            box-shadow: 0 0 10px #00ffcc;
        }
        #action-buttons-mobile {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        #upgrade-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px #ff00ff, 0 0 30px #00ffcc;
            display: none;
            border-radius: 5px;
            text-align: center;
            max-width: 90%;
        }
        #upgrade-menu h3 {
            margin: 0 0 10px;
            font-size: 14px;
            text-shadow: 0 0 5px #00ffcc;
        }
        #upgrade-menu p {
            margin: 5px 0;
            font-size: 12px;
        }
        #upgrade-menu button {
            width: 100%;
            margin: 5px 0;
        }
        #character-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: center;
        }
        #character-avatar {
            font-size: 40px;
            width: 50px;
            height: 50px;
            line-height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff00ff;
        }
        #character-level {
            font-size: 16px;
            margin-top: 5px;
            text-shadow: 0 0 5px #00ffcc;
        }
        #health-bar {
            width: 50px;
            height: 10px;
            background: #333;
            border: 1px solid #ff00ff;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        #health-fill {
            height: 100%;
            background: #00ffcc;
            width: 100%;
            transition: width 0.3s ease;
        }
        #mini-map {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }
        #mini-map-canvas {
            width: 100%;
            height: 100%;
        }
        .name-label {
            position: absolute;
            color: #00ffcc;
            font-size: 12px;
            text-shadow: 0 0 5px #ff00ff;
            pointer-events: none;
            text-align: center;
            width: 100px;
        }
    </style>
</head>
<body>
    <!-- –≠–∫—Ä–∞–Ω –∑–∞–≥—Ä—É–∑–∫–∏ -->
    <div id="loading-screen" class="screen">
        <h1 class="neon-text">–ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥ 2089</h1>
        <p>–ó–∞–≥—Ä—É–∑–∫–∞ —Å–∏—Å—Ç–µ–º—ã...</p>
    </div>

    <!-- –≠–∫—Ä–∞–Ω —Å–æ–∑–¥–∞–Ω–∏—è/–≤—ã–±–æ—Ä–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ -->
    <div id="character-screen" class="screen">
        <h1 class="neon-text">üåÉ –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥</h1>
        <div id="create-character">
            <input id="char-name" type="text" placeholder="–ò–º—è" style="width: 80px; background: #1a1a33; color: #00ffcc; border: 1px solid #ff00ff; padding: 2px;">
            <button onclick="createCharacter('–•–∞–∫–µ—Ä')">–•–∞–∫–µ—Ä</button>
            <button onclick="createCharacter('–ù–∞–µ–º–Ω–∏–∫')">–ù–∞–µ–º–Ω–∏–∫</button>
            <button onclick="createCharacter('–¢–µ—Ö–Ω–∏–∫')">–¢–µ—Ö–Ω–∏–∫</button>
        </div>
        <div id="character-list"></div>
    </div>

    <!-- –≠–∫—Ä–∞–Ω –∏–≥—Ä—ã -->
    <div id="game-screen" class="screen">
        <div id="character-hud">
            <div id="character-avatar">üòä</div>
            <div id="character-level">1</div>
            <div id="health-bar">
                <div id="health-fill"></div>
            </div>
        </div>
        <div id="mini-map">
            <canvas id="mini-map-canvas"></canvas>
        </div>
        <div id="welcome-message" class="neon-text">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥!</div>
        <div id="joystick">
            <div id="joystick-knob"></div>
        </div>
        <div id="action-buttons-mobile">
            <button ontouchstart="startMission()">–ú–∏—Å—Å–∏—è</button>
            <button ontouchstart="completeMission()">–í—ã–ø–æ–ª–Ω–∏—Ç—å</button>
            <button ontouchstart="attackEnemy()">–ê—Ç–∞–∫–∞</button>
            <button ontouchstart="showUpgradeMenu()">–ü—Ä–æ–∫–∞—á–∫–∞</button>
        </div>
        <div id="upgrade-menu">
            <h3 class="neon-text">–ü—Ä–æ–∫–∞—á–∫–∞ –∏ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h3>
            <p id="upgrade-stats"></p>
            <button ontouchstart="upgradeStat('strength')">–°–∏–ª–∞ +1 (100 –∫—Ä.)</button>
            <button ontouchstart="upgradeStat('intelligence')">–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç +1 (100 –∫—Ä.)</button>
            <button ontouchstart="upgradeStat('agility')">–õ–æ–≤–∫–æ—Å—Ç—å +1 (100 –∫—Ä.)</button>
            <button ontouchstart="hideUpgradeMenu()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script>
        // Telegram Web Apps
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();

        // –≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        const loadingScreen = document.getElementById("loading-screen");
        const characterScreen = document.getElementById("character-screen");
        const gameScreen = document.getElementById("game-screen");
        const welcomeMessage = document.getElementById("welcome-message");
        const createCharacterDiv = document.getElementById("create-character");
        const characterLevel = document.getElementById("character-level");
        const healthFill = document.getElementById("health-fill");
        const miniMapCanvas = document.getElementById("mini-map-canvas");
        const miniMapCtx = miniMapCanvas.getContext("2d");

        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let currentCharacter = null;
        let characters = [];
        let selectedCharacter = null;
        let currentMission = null;
        let itemObjects = [];
        let enemyObjects = [];
        let selectedEnemy = null;

        // –ö–≤–µ—Å—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞
        const quests = {
            "–•–∞–∫–µ—Ä": [
                { id: 1, desc: "–í–∑–ª–æ–º–∞–π —Ç–µ—Ä–º–∏–Ω–∞–ª –≤ –ù–µ–æ–Ω–æ–≤–æ–º —Ä–∞–π–æ–Ω–µ", target: [-30, -30], reward: 50, type: "hack", completed: false },
                { id: 2, desc: "–ü–æ–ª—É—á–∏ –¥–æ—Å—Ç—É–ø –∫ —Å–µ—Ä–≤–µ—Ä—É –≤ –ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–º —Å–µ–∫—Ç–æ—Ä–µ", target: [20, 20], reward: 100, type: "hack", completed: false },
                { id: 3, desc: "–†–∞—Å–∫—Ä–æ–π —Ç–∞–π–Ω—É Neon Core –Ω–∞ –°–≤–∞–ª–∫–µ", target: [0, 40], reward: 200, type: "hack", completed: false }
            ],
            "–ù–∞–µ–º–Ω–∏–∫": [
                { id: 1, desc: "–£–Ω–∏—á—Ç–æ–∂—å –¥—Ä–æ–Ω–∞ –Ω–∞ –°–≤–∞–ª–∫–µ", target: [30, 30], reward: 60, type: "fight", completed: false },
                { id: 2, desc: "–û—á–∏—Å—Ç–∏ –ù–µ–æ–Ω–æ–≤—ã–π —Ä–∞–π–æ–Ω –æ—Ç –æ—Ö—Ä–∞–Ω—ã", target: [-20, -20], reward: 120, type: "fight", completed: false },
                { id: 3, desc: "–õ–∏–∫–≤–∏–¥–∏—Ä—É–π –≥–ª–∞–≤–∞—Ä—è –≤ –ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω–æ–º —Å–µ–∫—Ç–æ—Ä–µ", target: [40, 0], reward: 250, type: "fight", completed: false }
            ],
            "–¢–µ—Ö–Ω–∏–∫": [
                { id: 1, desc: "–ü–æ—á–∏–Ω–∏ —ç–Ω–µ—Ä–≥–æ–±–ª–æ–∫ –≤ —Ü–µ–Ω—Ç—Ä–µ", target: [0, 0], reward: 55, type: "repair", completed: false },
                { id: 2, desc: "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ –¥—Ä–æ–Ω–∞ –Ω–∞ –°–≤–∞–ª–∫–µ", target: [20, -20], reward: 110, type: "repair", completed: false },
                { id: 3, desc: "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏ —Å–µ—Ç—å –≤ –ù–µ–æ–Ω–æ–≤–æ–º —Ä–∞–π–æ–Ω–µ", target: [-40, 0], reward: 220, type: "repair", completed: false }
            ]
        };

        // –ó–æ–Ω—ã –∫–∞—Ä—Ç—ã
        const zones = [
            { name: "–ù–µ–æ–Ω–æ–≤—ã–π —Ä–∞–π–æ–Ω", x: -25, z: -25, color: "#ff00ff" },
            { name: "–°–≤–∞–ª–∫–∞", x: 25, z: 25, color: "#ffff00" },
            { name: "–ö–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π —Å–µ–∫—Ç–æ—Ä", x: 25, z: -25, color: "#00ffcc" }
        ];

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ü–µ–Ω—ã Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "low-power" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById("game-screen").appendChild(renderer.domElement);

        // –¢–µ–∫—Å—Ç—É—Ä—ã
        const textureLoader = new THREE.TextureLoader();
        const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
        groundTexture.repeat.set(10, 10);
        const buildingTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');

        // –ó–µ–º–ª—è
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshBasicMaterial({ map: groundTexture });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // –ó–¥–∞–Ω–∏—è
        const buildingMaterial = new THREE.MeshBasicMaterial({ map: buildingTexture });
        for (let i = 0; i < 20; i++) {
            const height = Math.random() * 15 + 5;
            const building = new THREE.Mesh(new THREE.BoxGeometry(5, height, 5), buildingMaterial);
            building.position.set(Math.random() * 90 - 45, height / 2, Math.random() * 90 - 45);
            scene.add(building);
        }

        // –ù–µ–æ–Ω–æ–≤—ã–π –¥–æ–∂–¥—å
        const particleCount = 500;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = Math.random() * 100 - 50;
            positions[i * 3 + 1] = Math.random() * 20 + 5;
            positions[i * 3 + 2] = Math.random() * 100 - 50;
            colors[i * 3] = Math.random() > 0.5 ? 1 : 0;
            colors[i * 3 + 1] = 0;
            colors[i * 3 + 2] = Math.random() > 0.5 ? 1 : 0;
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const particlesMaterial = new THREE.PointsMaterial({ size: 0.2, vertexColors: true, transparent: true });
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // –û—Å–≤–µ—â–µ–Ω–∏–µ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const neonLight = new THREE.PointLight(0xff00ff, 1, 50);
        neonLight.position.set(0, 10, 0);
        scene.add(neonLight);

        // –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –º–∏—Å—Å–∏–π
        const missionObjects = [];
        function createMissionObjects() {
            missionObjects.forEach(obj => scene.remove(obj));
            missionObjects.length = 0;

            const terminal = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
            terminal.position.set(-30, 1, -30);
            terminal.userData = { type: "hack" };
            scene.add(terminal);
            missionObjects.push(terminal);

            const drone = new THREE.Mesh(new THREE.SphereGeometry(0.5, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff00ff }));
            drone.position.set(30, 1, 30);
            drone.userData = { type: "fight" };
            scene.add(drone);
            missionObjects.push(drone);

            const energyBlock = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            energyBlock.position.set(0, 0.75, 0);
            energyBlock.userData = { type: "repair" };
            scene.add(energyBlock);
            missionObjects.push(energyBlock);
        }

        // –ü—Ä–µ–¥–º–µ—Ç—ã –Ω–∞ –∫–∞—Ä—Ç–µ
        function createItems() {
            itemObjects.forEach(obj => scene.remove(obj));
            itemObjects.length = 0;

            const chip = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
            chip.position.set(-20, 0.25, -20);
            chip.userData = { type: "item", name: "–ß–∏–ø –¥–æ—Å—Ç—É–ø–∞", effect: { intelligence: 5 } };
            scene.add(chip);
            itemObjects.push(chip);

            const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xff00ff }));
            weapon.position.set(20, 0.25, 20);
            weapon.userData = { type: "item", name: "–ö–∏–±–µ—Ä-–æ—Ä—É–∂–∏–µ", effect: { strength: 5 } };
            scene.add(weapon);
            itemObjects.push(weapon);

            const module = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            module.position.set(20, 0.25, -20);
            module.userData = { type: "item", name: "–≠–Ω–µ—Ä–≥–æ-–º–æ–¥—É–ª—å", effect: { agility: 5 } };
            scene.add(module);
            itemObjects.push(module);
        }

        // –í—Ä–∞–≥–∏ –Ω–∞ –∫–∞—Ä—Ç–µ
        function createEnemies() {
            enemyObjects.forEach(obj => {
                scene.remove(obj);
                if (obj.label) document.body.removeChild(obj.label);
            });
            enemyObjects.length = 0;

            const rogueDrone = new THREE.Mesh(new THREE.SphereGeometry(0.7, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff5555 }));
            rogueDrone.position.set(25, 0.7, 25);
            rogueDrone.userData = { type: "enemy", name: "–ë—É–Ω—Ç—É—é—â–∏–π –¥—Ä–æ–Ω", stats: { health: 20, strength: 5 }, reward: 30 };
            const rogueDroneLabel = document.createElement("div");
            rogueDroneLabel.className = "name-label";
            rogueDroneLabel.textContent = "–ë—É–Ω—Ç—É—é—â–∏–π –¥—Ä–æ–Ω";
            document.body.appendChild(rogueDroneLabel);
            rogueDrone.label = rogueDroneLabel;
            scene.add(rogueDrone);
            enemyObjects.push(rogueDrone);

            const guard = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.5, 0.8), new THREE.MeshBasicMaterial({ color: 0x5555ff }));
            guard.position.set(-25, 0.75, -25);
            guard.userData = { type: "enemy", name: "–û—Ö—Ä–∞–Ω–Ω–∏–∫", stats: { health: 30, strength: 8 }, reward: 50 };
            const guardLabel = document.createElement("div");
            guardLabel.className = "name-label";
            guardLabel.textContent = "–û—Ö—Ä–∞–Ω–Ω–∏–∫";
            document.body.appendChild(guardLabel);
            guard.label = guardLabel;
            scene.add(guard);
            enemyObjects.push(guard);

            const cyberBeast = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.2, 8), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
            cyberBeast.position.set(25, 0.6, -25);
            cyberBeast.userData = { type: "enemy", name: "–ö–∏–±–µ—Ä-–∑–≤–µ—Ä—å", stats: { health: 40, strength: 10 }, reward: 70 };
            const cyberBeastLabel = document.createElement("div");
            cyberBeastLabel.className = "name-label";
            cyberBeastLabel.textContent = "–ö–∏–±–µ—Ä-–∑–≤–µ—Ä—å";
            document.body.appendChild(cyberBeastLabel);
            cyberBeast.label = cyberBeastLabel;
            scene.add(cyberBeast);
            enemyObjects.push(cyberBeast);
        }

        // –°–æ–∑–¥–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
        function createCharacterModel(role) {
            if (currentCharacter) {
                scene.remove(currentCharacter);
                if (currentCharacter.label) document.body.removeChild(currentCharacter.label);
            }
            const group = new THREE.Group();
            let color = role === "–•–∞–∫–µ—Ä" ? 0x00ffcc : role === "–ù–∞–µ–º–Ω–∏–∫" ? 0xff00ff : 0xffff00;
            const material = new THREE.MeshBasicMaterial({ color });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 1.2, 8), material);
            body.position.y = 0.6;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), material);
            head.position.y = 1.3;
            group.add(head);

            currentCharacter = group;
            currentCharacter.position.set(0, 0, 0);
            const nameLabel = document.createElement("div");
            nameLabel.className = "name-label";
            nameLabel.textContent = selectedCharacter ? selectedCharacter.name : "–ò–≥—Ä–æ–∫";
            document.body.appendChild(nameLabel);
            currentCharacter.label = nameLabel;
            scene.add(currentCharacter);
        }

        // –î–∂–æ–π—Å—Ç–∏–∫
        const joystick = document.getElementById("joystick");
        const knob = document.getElementById("joystick-knob");
        let joystickActive = false;
        let joystickOrigin = { x: 0, y: 0 };
        let direction = { x: 0, y: 0 };

        joystick.addEventListener("touchstart", (e) => {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            joystickOrigin = { x: touch.clientX, y: touch.clientY };
        });

        joystick.addEventListener("touchmove", (e) => {
            e.preventDefault();
            if (!joystickActive || !currentCharacter) return;
            const touch = e.touches[0];
            const dx = touch.clientX - joystickOrigin.x;
            const dy = touch.clientY - joystickOrigin.y;
            const distance = Math.min(40, Math.sqrt(dx * dx + dy * dy));
            const angle = Math.atan2(dy, dx);
            direction.x = Math.cos(angle) * (distance / 40);
            direction.y = Math.sin(angle) * (distance / 40);
            knob.style.left = `${20 + Math.cos(angle) * distance}px`;
            knob.style.top = `${20 + Math.sin(angle) * distance}px`;
        });

        joystick.addEventListener("touchend", () => {
            joystickActive = false;
            direction = { x: 0, y: 0 };
            knob.style.left = "20px";
            knob.style.top = "20px";
        });

        // –ú–∏–Ω–∏-–∫–∞—Ä—Ç–∞
        function updateMiniMap() {
            miniMapCtx.clearRect(0, 0, 100, 100);
            miniMapCtx.fillStyle = "rgba(0, 0, 0, 0.5)";
            miniMapCtx.fillRect(0, 0, 100, 100);

            zones.forEach(zone => {
                const x = (zone.x + 50) / 100 * 100;
                const z = (zone.z + 50) / 100 * 100;
                miniMapCtx.fillStyle = zone.color;
                miniMapCtx.beginPath();
                miniMapCtx.arc(x, z, 10, 0, Math.PI * 2);
                miniMapCtx.fill();
            });

            if (currentCharacter) {
                const playerX = (currentCharacter.position.x + 50) / 100 * 100;
                const playerZ = (currentCharacter.position.z + 50) / 100 * 100;
                miniMapCtx.fillStyle = "#ffffff";
                miniMapCtx.beginPath();
                miniMapCtx.arc(playerX, playerZ, 3, 0, Math.PI * 2);
                miniMapCtx.fill();
            }

            if (currentMission) {
                const missionX = (currentMission.target[0] + 50) / 100 * 100;
                const missionZ = (currentMission.target[1] + 50) / 100 * 100;
                miniMapCtx.fillStyle = "#ff0000";
                miniMapCtx.beginPath();
                miniMapCtx.arc(missionX, missionZ, 3, 0, Math.PI * 2);
                miniMapCtx.fill();
            }
        }

        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ 3D-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ 2D-—ç–∫—Ä–∞–Ω–Ω—ã–µ
        function toScreenPosition(obj, camera) {
            const vector = new THREE.Vector3();
            obj.updateMatrixWorld();
            vector.setFromMatrixPosition(obj.matrixWorld);
            vector.project(camera);
            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;
            return {
                x: (vector.x * widthHalf) + widthHalf,
                y: -(vector.y * heightHalf) + heightHalf
            };
        }

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∞–Ω–∏—è –ø–æ –º–æ–Ω—Å—Ç—Ä—É
        renderer.domElement.addEventListener("touchstart", (event) => {
            event.preventDefault();
            const touch = event.touches[0];
            const mouse = new THREE.Vector2();
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(enemyObjects);
            if (intersects.length > 0) {
                const enemy = intersects[0].object;
                if (selectedEnemy && selectedEnemy !== enemy) {
                    selectedEnemy.material.emissive.setHex(0x000000);
                }
                selectedEnemy = enemy;
                enemy.material.emissive.setHex(0xffffff);
                appendMessage(`${enemy.userData.name}: –ó–¥–æ—Ä–æ–≤—å–µ ${enemy.userData.stats.health}`);
            }
        });

        // –ê–Ω–∏–º–∞—Ü–∏—è –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
        function animate() {
            requestAnimationFrame(animate);

            if (currentCharacter) {
                const speed = 0.1;
                currentCharacter.position.x += direction.x * speed;
                currentCharacter.position.z += direction.y * speed;

                currentCharacter.position.x = Math.max(-50, Math.min(50, currentCharacter.position.x));
                currentCharacter.position.z = Math.max(-50, Math.min(50, currentCharacter.position.z));

                if (direction.x !== 0 || direction.y !== 0) {
                    currentCharacter.rotation.y = Math.atan2(direction.x, direction.y);
                    currentCharacter.children[0].rotation.z = Math.sin(Date.now() * 0.01) * 0.1;
                }

                camera.position.set(
                    currentCharacter.position.x,
                    currentCharacter.position.y + 8,
                    currentCharacter.position.z + 15
                );
                camera.lookAt(currentCharacter.position);

                const playerScreenPos = toScreenPosition(currentCharacter, camera);
                currentCharacter.label.style.left = `${playerScreenPos.x - 50}px`;
                currentCharacter.label.style.top = `${playerScreenPos.y - 20}px`;

                itemObjects.forEach((item, index) => {
                    const dist = Math.sqrt(
                        Math.pow(currentCharacter.position.x - item.position.x, 2) +
                        Math.pow(currentCharacter.position.z - item.position.z, 2)
                    );
                    if (dist < 1 && item.visible) {
                        selectedCharacter.inventory.push(item.userData);
                        appendMessage(`–ü–æ–¥–æ–±—Ä–∞–Ω –ø—Ä–µ–¥–º–µ—Ç: ${item.userData.name}`);
                        item.visible = false;
                        itemObjects.splice(index, 1);
                        saveProgress();
                    }
                });

                enemyObjects.forEach(enemy => {
                    if (enemy.visible) {
                        const enemyScreenPos = toScreenPosition(enemy, camera);
                        enemy.label.style.left = `${enemyScreenPos.x - 50}px`;
                        enemy.label.style.top = `${enemyScreenPos.y - 20}px`;
                    } else {
                        enemy.label.style.display = "none";
                    }
                });

                updateHUD();
                updateMiniMap();
            }

            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3 + 1] -= 0.05;
                if (positions[i * 3 + 1] < 0) {
                    positions[i * 3 + 1] = Math.random() * 20 + 5;
                    positions[i * 3] = Math.random() * 100 - 50;
                    positions[i * 3 + 2] = Math.random() * 100 - 50;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞–º–∏
        function showScreen(screenId) {
            loadingScreen.style.display = "none";
            characterScreen.style.display = "none";
            gameScreen.style.display = "none";
            document.getElementById(screenId).style.display = "flex";
        }

        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        function showWelcomeMessage() {
            welcomeMessage.style.opacity = "1";
            setTimeout(() => {
                welcomeMessage.style.opacity = "0";
            }, 4000);
        }

        // –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã
        function appendMessage(text) {
            window.Telegram.WebApp.showAlert(text);
        }

        function createCharacter(role) {
            if (characters.length >= 3) {
                appendMessage("–ú–∞–∫—Å–∏–º—É–º 3 –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!");
                return;
            }
            const name = document.getElementById("char-name").value.trim();
            if (!name) {
                appendMessage("–í–≤–µ–¥–∏ –∏–º—è!");
                return;
            }
            const character = {
                name,
                role,
                creds: 0,
                health: 100,
                level: 1,
                stats: {
                    strength: role === "–ù–∞–µ–º–Ω–∏–∫" ? 10 : 5,
                    intelligence: role === "–•–∞–∫–µ—Ä" ? 10 : 5,
                    agility: role === "–¢–µ—Ö–Ω–∏–∫" ? 10 : 5
                },
                inventory: [],
                questProgress: 0
            };
            characters.push(character);
            document.getElementById("char-name").value = "";
            updateCharacterList();
            saveProgress();
            appendMessage(`–ü–µ—Ä—Å–æ–Ω–∞–∂ ${name} —Å–æ–∑–¥–∞–Ω!`);
        }

        function updateCharacterList() {
            const charList = document.getElementById("character-list");
            charList.innerHTML = "<h3>–ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</h3>";
            characters.forEach((char, index) => {
                charList.innerHTML += `
                    <button ontouchstart="selectCharacter(${index})">
                        ${char.name} (${char.role}) - ${char.creds} –∫—Ä. [–ó–¥:${char.health}] –£—Ä.${char.level}
                        [–°:${char.stats.strength} –ò:${char.stats.intelligence} –õ:${char.stats.agility}]
                    </button><br>`;
            });
            if (characters.length >= 3) createCharacterDiv.style.display = "none";
            else createCharacterDiv.style.display = "block";
        }

        function selectCharacter(index) {
            selectedCharacter = characters[index];
            createCharacterModel(selectedCharacter.role);
            createMissionObjects();
            createItems();
            createEnemies();
            showScreen("game-screen");
            showWelcomeMessage();
            appendMessage(`–í—ã–±—Ä–∞–Ω: ${selectedCharacter.name}. –ò—Å—Å–ª–µ–¥—É–π –ö–∏–±–µ—Ä-–ì–æ—Ä–æ–¥ –∏ –Ω–∞—á–Ω–∏ –º–∏—Å—Å–∏—é!`);
            updateHUD();
        }

        function startMission() {
            if (!selectedCharacter) return;
            const questList = quests[selectedCharacter.role];
            const currentQuestIndex = selectedCharacter.questProgress;
            if (currentQuestIndex >= questList.length) {
                appendMessage("–í—Å–µ –∫–≤–µ—Å—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã!");
                return;
            }
            currentMission = questList[currentQuestIndex];
            appendMessage(`–ö–≤–µ—Å—Ç ${currentMission.id}: ${currentMission.desc}. –ò–¥–∏ –∫ (${currentMission.target[0]}, ${currentMission.target[1]}). –ù–∞–≥—Ä–∞–¥–∞: ${currentMission.reward} –∫—Ä.`);
        }

        function completeMission() {
            if (!selectedCharacter || !currentMission) return;
            const pos = currentCharacter.position;
            const [targetX, targetZ] = currentMission.target;
            if (Math.abs(pos.x - targetX) < 1 && Math.abs(pos.z - targetZ) < 1) {
                selectedCharacter.creds += currentMission.reward;
                appendMessage(`‚ö°Ô∏è ${currentMission.desc}: +${currentMission.reward} –∫—Ä.`);
                window.Telegram.WebApp.showAlert(`–ö–≤–µ—Å—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω! +${currentMission.reward} –∫—Ä–µ–¥–∏—Ç–æ–≤`);
                missionObjects.find(obj => obj.userData.type === currentMission.type && 
                    Math.abs(obj.position.x - targetX) < 1 && Math.abs(obj.position.z - targetZ) < 1).visible = false;
                setTimeout(() => createMissionObjects(), 5000);
                currentMission.completed = true;
                selectedCharacter.questProgress += 1;
                currentMission = null;
                updateCharacterList();
                saveProgress();
                if (selectedCharacter.questProgress < quests[selectedCharacter.role].length) {
                    appendMessage(`–°–ª–µ–¥—É—é—â–∏–π –∫–≤–µ—Å—Ç –¥–æ—Å—Ç—É–ø–µ–Ω! –ù–∞–∂–º–∏ "–ú–∏—Å—Å–∏—è".`);
                } else {
                    appendMessage("–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—Å–µ –∫–≤–µ—Å—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã!");
                }
            } else {
                appendMessage("üí• –¢—ã –Ω–µ –≤ —Ç–æ—á–∫–µ —Ü–µ–ª–∏!");
            }
        }

        // –õ–æ–≥–∏–∫–∞ –±–æ—è —Å –≤—Ä–∞–≥–∞–º–∏
        function attackEnemy() {
            if (!selectedCharacter) return;
            let nearestEnemy = null;
            let minDist = Infinity;

            enemyObjects.forEach(enemy => {
                if (enemy.visible) {
                    const dist = Math.sqrt(
                        Math.pow(currentCharacter.position.x - enemy.position.x, 2) +
                        Math.pow(currentCharacter.position.z - enemy.position.z, 2)
                    );
                    if (dist < minDist && dist < 2) {
                        minDist = dist;
                        nearestEnemy = enemy;
                    }
                }
            });

            if (!nearestEnemy) {
                appendMessage("–ù–µ—Ç –≤—Ä–∞–≥–æ–≤ –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏!");
                return;
            }

            const playerAttack = selectedCharacter.stats.strength + Math.floor(Math.random() * 5);
            const enemyAttack = nearestEnemy.userData.stats.strength + Math.floor(Math.random() * 5);
            const enemyHealth = nearestEnemy.userData.stats.health;

            if (playerAttack > enemyAttack) {
                nearestEnemy.userData.stats.health -= playerAttack;
                appendMessage(`–¢—ã –∞—Ç–∞–∫–æ–≤–∞–ª ${nearestEnemy.userData.name}! –ù–∞–Ω–µ—Å—ë–Ω —É—Ä–æ–Ω: ${playerAttack}. –ó–¥–æ—Ä–æ–≤—å–µ –≤—Ä–∞–≥–∞: ${nearestEnemy.userData.stats.health}`);
                if (nearestEnemy.userData.stats.health <= 0) {
                    selectedCharacter.creds += nearestEnemy.userData.reward;
                    appendMessage(`‚ö°Ô∏è ${nearestEnemy.userData.name} –ø–æ–±–µ–∂–¥—ë–Ω! +${nearestEnemy.userData.reward} –∫—Ä.`);
                    nearestEnemy.visible = false;
                    document.body.removeChild(nearestEnemy.label);
                    enemyObjects = enemyObjects.filter(e => e !== nearestEnemy);
                    if (selectedEnemy === nearestEnemy) selectedEnemy = null;
                    saveProgress();
                }
            } else {
                selectedCharacter.health -= enemyAttack;
                appendMessage(`–í—Ä–∞–≥ ${nearestEnemy.userData.name} –∞—Ç–∞–∫–æ–≤–∞–ª —Ç–µ–±—è! –£—Ä–æ–Ω: ${enemyAttack}. –¢–≤–æ—ë –∑–¥–æ—Ä–æ–≤—å–µ: ${selectedCharacter.health}`);
                if (selectedCharacter.health <= 0) {
                    appendMessage("–¢—ã –ø–æ–±–µ–∂–¥—ë–Ω! –í–æ–∑–≤—Ä–∞—â–∞–π—Å—è –Ω–∞ –±–∞–∑—É –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è.");
                    selectedCharacter.health = 100;
                    currentCharacter.position.set(0, 0, 0);
                }
            }
            updateCharacterList();
            saveProgress();
            updateHUD();
        }

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ HUD
        function updateHUD() {
            if (selectedCharacter) {
                characterLevel.textContent = selectedCharacter.level || 1;
                healthFill.style.width = `${Math.max(0, (selectedCharacter.health / 100) * 100)}%`;
            }
        }

        // –ü—Ä–æ–∫–∞—á–∫–∞ –∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
        const upgradeMenu = document.getElementById("upgrade-menu");
        const upgradeStats = document.getElementById("upgrade-stats");

        function showUpgradeMenu() {
            if (!selectedCharacter) return;
            let inventoryText = selectedCharacter.inventory.length > 0 
                ? "–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: " + selectedCharacter.inventory.map(item => item.name).join(", ") 
                : "–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç";
            upgradeStats.innerHTML = `${selectedCharacter.name}: ${selectedCharacter.creds} –∫—Ä.<br>
                –ó–¥–æ—Ä–æ–≤—å–µ: ${selectedCharacter.health}<br>
                –£—Ä–æ–≤–µ–Ω—å: ${selectedCharacter.level || 1}<br>
                –°–∏–ª–∞: ${selectedCharacter.stats.strength}<br>
                –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç: ${selectedCharacter.stats.intelligence}<br>
                –õ–æ–≤–∫–æ—Å—Ç—å: ${selectedCharacter.stats.agility}<br>
                ${inventoryText}`;
            upgradeMenu.style.display = "block";
        }

        function hideUpgradeMenu() {
            upgradeMenu.style.display = "none";
        }

        function upgradeStat(stat) {
            if (!selectedCharacter || selectedCharacter.creds < 100) {
                appendMessage("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!");
                window.Telegram.WebApp.showAlert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!");
                return;
            }
            selectedCharacter.creds -= 100;
            selectedCharacter.stats[stat] += 1;
            appendMessage(`–£–ª—É—á—à–µ–Ω–æ: ${stat === "strength" ? "–°–∏–ª–∞" : stat === "intelligence" ? "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç" : "–õ–æ–≤–∫–æ—Å—Ç—å"} +1!`);
            window.Telegram.WebApp.showAlert(`–£–ª—É—á—à–µ–Ω–æ: ${stat === "strength" ? "–°–∏–ª–∞" : stat === "intelligence" ? "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç" : "–õ–æ–≤–∫–æ—Å—Ç—å"} +1`);
            updateCharacterList();
            saveProgress();
            showUpgradeMenu();
            updateHUD();
        }

        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function saveProgress() {
            try {
                window.Telegram.WebApp.CloudStorage.setItem("characters", JSON.stringify(characters), () => {
                    console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω");
                });
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:", e);
            }
        }

        function loadProgress(callback) {
            try {
                window.Telegram.WebApp.CloudStorage.getItem("characters", (error, result) => {
                    if (!error && result) {
                        characters = JSON.parse(result);
                        console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å –∑–∞–≥—Ä—É–∂–µ–Ω:", characters);
                    } else {
                        console.log("–ü—Ä–æ–≥—Ä–µ—Å—Å –Ω–µ –Ω–∞–π–¥–µ–Ω, –Ω–æ–≤—ã–π —Å—Ç–∞—Ä—Ç");
                    }
                    callback();
                });
            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:", e);
                callback();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        function initializeGame() {
            showScreen("loading-screen");
            loadProgress(() => {
                setTimeout(() => {
                    updateCharacterList();
                    showScreen("character-screen");
                }, 2000);
            });
        }

        initializeGame();

        // –ê–¥–∞–ø—Ç–∞—Ü–∏—è –ø–æ–¥ —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
